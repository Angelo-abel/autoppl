<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>autoppl: AutoPPL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">autoppl
   &#160;<span id="projectnumber">v0.8</span>
   </div>
   <div id="projectbrief">A C++ template library for probabilistic programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">AutoPPL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <a href="#contributors"><img src="https://img.shields.io/badge/all_contributors-4-orange.svg?style=flat-square" alt="All Contributors" style="pointer-events: none;" class="inline"/></a></p>
<p><a href="https://travis-ci.org/JamesYang007/autoppl"><img src="https://travis-ci.org/JamesYang007/autoppl.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a> <a href="https://coveralls.io/github/JamesYang007/autoppl?branch=master"><img src="https://coveralls.io/repos/github/JamesYang007/autoppl/badge.svg?branch=master" alt="Coverage Status" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<ul>
<li><a href="#overview">Overview</a><ul>
<li><a href="#who-should-use-autoppl">Who should use AutoPPL?</a></li>
<li><a href="#how-is-autoppl-different-from-existing-ppls-like-stan-and-pymc3">How is AutoPPL different from existing PPLs like STAN and PyMC3?</a></li>
</ul>
</li>
<li><a href="#design-choices">Design Choices</a><ul>
<li><a href="#intuitive-model-specification">Intuitive Model Specification</a></li>
<li><a href="#efficient-memory-usage">Efficient Memory Usage</a></li>
<li><a href="#high-performance-inference-methods">High-performance Inference Methods</a></li>
</ul>
</li>
<li><a href="#installation">Installation</a></li>
<li><a href="#quick-guide">Quick Guide</a><ul>
<li><a href="#variable">Variable</a></li>
<li><a href="#variable-expression">Variable Expression</a></li>
<li><a href="#constraint">Constraint</a></li>
<li><a href="#distribution-expression">Distribution Expression</a></li>
<li><a href="#model-expression">Model Expression</a></li>
<li><a href="#transformed-parameters">Transformed Parameters</a></li>
<li><a href="#program-expression">Program Expression</a></li>
<li><a href="#sampling-algorithms">Sampling Algorithms</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#sampling-from-joint-distribution">Sampling from Joint Distribution</a></li>
<li><a href="#sampling-posterior-mean-and-standard-deviation">Sampling Posterior Mean and Standard Deviation</a></li>
<li><a href="#bayesian-linear-regression">Bayesian Linear Regression</a></li>
<li><a href="#stochastic-volatility">Stochastic Volatility</a></li>
</ul>
</li>
<li><a href="#benchmarks">Benchmarks</a><ul>
<li><a href="#benchmarks-bayesian-linear-regression">Bayesian Linear Regression</a></li>
<li><a href="#gaussian-model">Gaussian Model</a></li>
</ul>
</li>
<li><a href="#contributors">Contributors</a></li>
<li><a href="#third-party-tools">Third Party Tools</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Overview</h1>
<p>AutoPPL is a C++ template library providing high-level support for probabilistic programming. Using operator overloading and expression templates, AutoPPL provides a generic framework for specifying probabilistic models and applying inference algorithms.</p>
<p>The library is still at an experimental stage.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Who should use AutoPPL?</h2>
<p>The goal of this project is to provide a framework for practitioners, students, and researchers. It is often desired to have a framework for specifying a probabilistic model separate from any inference algorithms. While AutoPPL does provide a few inference algorithms such as NUTS and Metropolis-Hastings, it allows users to write their <em>own</em> sampling algorithms and even add new distributions.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
How is AutoPPL different from existing PPLs like STAN and PyMC3?</h2>
<p>AutoPPL can be thought of as a hybrid of STAN and PyMC3. It is similar to STAN in that it is extremely optimized for high performance (see <a href="#benchmarks">Benchmarks</a>) and it uses much of the same logic discussed in the STAN reference guide. It is similar to PyMC3 in that it is a library rather than a separate domain-specific language.</p>
<p>However, it is unique in that it is purely a C++ library. While STAN requires the user to write STAN code, which gets translated into C++ code by the STAN compiler and then compiled into a binary, AutoPPL just requires the user to directly write C++ code. Some benefits include the following:</p><ul>
<li>eliminates the extra layer of abstraction to a separate domain-specific language</li>
<li>users can use native C++ tools to clean and prepare data, and also examine the posterior samples</li>
<li>easily extend the library such as adding new distributions or a sampling algorithm</li>
</ul>
<p>In the future, we plan to provide Python and R bindings such that the user can write a C++ function using AutoPPL that defines and samples from the model and export the Python/R binding to examine the posterior samples using a more comfortable, scripting language.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Design Choices</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
Intuitive Model Specification</h2>
<p>In Bayesian statistics, the first step in performing probabilistic inference is to specify a generative model for the data of interest. For example, in mathematical notation, a Gaussian model could look like the following: </p><div class="fragment"><div class="line">X ~ Normal(theta, I)</div>
<div class="line">theta ~ Uniform(-1, 1)</div>
</div><!-- fragment --><p>Given its simplicity and expressiveness, we wanted to mimic this compact notation as much as possible for users of our library. For the model specified above, the code in AutoPPL could look like the following: </p><div class="fragment"><div class="line">Data&lt;double, vec&gt; X({...});   <span class="comment">// load data</span></div>
<div class="line">Param&lt;double&gt; theta;          <span class="comment">// define scalar parameter</span></div>
<div class="line"><span class="keyword">auto</span> model = (                <span class="comment">// specify model</span></div>
<div class="line">    theta |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(-1., 1.),</div>
<div class="line">    X |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(theta, 1.)</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Efficient Memory Usage</h2>
<p>We make the assumption that users are able to specify the probabilistic model at compile-time. As a result, AutoPPL can construct all model expressions at compile-time simply from the type information. A model object makes no heap-allocations (with the exception of <code><a class="el" href="namespaceppl.html#ad3d5823ebc58b089ab53f40477c3dff0">ppl::for_each</a></code>) and is minimal in size. It is simply a small, contiguous slab of memory representing the binary tree. The <code>model</code> object in the <a href="#intuitive-model-specification">previous section</a> is about <code>88 bytes</code> on <code>x86_64-apple-darwin17.7.0</code> using <code>clang-11.0.3</code>.</p>
<p>For a more complicated model such as the following: </p><div class="fragment"><div class="line">Data&lt;double&gt; X;</div>
<div class="line">std::array&lt;Param&lt;double&gt;, 6&gt; theta;</div>
<div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">    theta[0] |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(-1., 1.),</div>
<div class="line">    theta[1] |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(theta[0], theta[0] + 2.),</div>
<div class="line">    theta[2] |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(theta[1], theta[0] * theta[0]),</div>
<div class="line">    theta[3] |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(-2., 1.),</div>
<div class="line">    theta[4] |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(-0.5, 0.5),</div>
<div class="line">    theta[5] |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(theta[2] + theta[3], theta[4]),</div>
<div class="line">    X |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(theta[5], 1.)</div>
<div class="line">);</div>
</div><!-- fragment --><p>The size of the model is <code>440 bytes</code> on the same machine and compiler.</p>
<p>A model expression simply references the variables used in the expression such as <code>theta[0], theta[1], ..., theta[5], X</code>, i.e. it does not copy any data or values.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
High-performance Inference Methods</h2>
<p>Users interface with the inference methods via model expressions and other configuration parameters for that particular method. Hence, the inference algorithms are completely general and work with any model so long as the model expression is properly constructed. Due to the statically-known model specification, algorithms have opportunities to make compile-time optimizations. See <a href="#benchmarks">Benchmarks</a> for performance comparisons with STAN.</p>
<p>We were largely inspired by STAN and followed their <a href="https://mc-stan.org/docs/2_23/reference-manual/index.html">reference</a> and also their <a href="https://github.com/stan-dev/stan">implementation</a> to compute ESS, perform adaptations, and stabilize sampling algorithms. However, our library works very differently underneath, especially with automatic differentiation and handling model expressions.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Installation</h1>
<p>First, clone the repository: </p><div class="fragment"><div class="line">git clone https://github.com/JamesYang007/autoppl ~/autoppl</div>
</div><!-- fragment --><p>The following are the dependencies:</p><ul>
<li><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen3.3</a></li>
<li><a href="https://github.com/JamesYang007/FastAD">FastAD</a></li>
</ul>
<p>We provide a shell script for Mac and Linux that automatically installs these libraries locally in <code>lib</code>: </p><div class="fragment"><div class="line">cd ~/autoppl</div>
<div class="line">./setup.sh</div>
</div><!-- fragment --><p>Since AutoPPL is a template library, there is nothing to build! Just pass the compiler flag <code>-I&lt;path&gt;</code> when building your program to include the path to <code>include</code> inside cloned directory, <code>include</code> to Eigen3.3, and <code>include</code> to FastAD. If you ran <code>./setup.sh</code>, the paths for the latter two are <code>lib/FastAD/libs/eigen-3.3.7/build/include</code> and <code>lib/FastAD/build/include</code> (relative to cloned directory).</p>
<p>For CMake users, they can follow these steps: </p><div class="fragment"><div class="line">./clean-build.sh release -DCMAKE_INSTALL_PREFIX=.. -DAUTOPPL_ENABLE_TEST=OFF</div>
<div class="line">cd build/release</div>
<div class="line">make install</div>
</div><!-- fragment --><p>This will simply set the CMake variable <code>CMAKE_INSTALL_PREFIX</code> to the <code>build</code> directory and won't build anything. If you want to install AutoPPL into the system, remove <code>-DCMAKE_INSTALL_PREFIX=..</code>. The <code>make install</code> will install the <code>include</code> directory and CMake shared files in <code>build</code> directory.</p>
<p>In your own CMake project, assuming you have a single source file <code>main.cpp</code> in the same directory as your CMakeLists.txt, write the following as a minimal configuration: </p><div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.7)</div>
<div class="line">project(&quot;MyProject&quot;)</div>
<div class="line">find_package(AutoPPL CONFIG REQUIRED)</div>
<div class="line">find_package(FastAD CONFIG REQUIRED)</div>
<div class="line">find_package(Eigen3 CONFIG REQUIRED)</div>
<div class="line">add_executable(main main.cpp)</div>
<div class="line">target_link_libraries(main AutoPPL::AutoPPL FastAD::FastAD Eigen3::Eigen)</div>
</div><!-- fragment --><p>If you installed <code>AutoPPL</code> locally as instructed before, you should add a hint to the <code>find_package</code> like: </p><div class="fragment"><div class="line">find_package(AutoPPL CONFIG REQUIRED HINTS path_to_autoppl/build/share)</div>
</div><!-- fragment --><p>The above rule applies for <code>FastAD</code> and <code>Eigen3</code> as well. If you installed these libraries using <code>setup.sh</code> locally, the required hint paths are: </p><div class="fragment"><div class="line">find_package(FastAD CONFIG REQUIRED HINTS path_to_autoppl/lib/FastAD/build/share)</div>
<div class="line">find_package(Eigen3 CONFIG REQUIRED HINTS path_to_autoppl/lib/FastAD/libs/Eigen3/build/share)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Quick Guide</h1>
<p>We assume that we are in <code>namespace ppl</code> throughout this section.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Variable</h2>
<p>There are only a few variable types that a user will need to define a model. </p><div class="fragment"><div class="line">DataView&lt;ValueType, ShapeType&gt; Xv(ptr, <a class="code" href="namespaceppl_1_1util.html#a249cf20fa5a16616cfab9104e2a67687">rows</a>, <a class="code" href="namespaceppl_1_1util.html#adf3136a2bba83dcc18c39a41409d96a0">cols</a>);</div>
<div class="line">Data&lt;ValueType, ShapeType&gt; X(<a class="code" href="namespaceppl_1_1util.html#a249cf20fa5a16616cfab9104e2a67687">rows</a>, <a class="code" href="namespaceppl_1_1util.html#adf3136a2bba83dcc18c39a41409d96a0">cols</a>);</div>
<div class="line">Param&lt;ValueType, ShapeType, ConstraintType&gt; p(<a class="code" href="namespaceppl_1_1util.html#a249cf20fa5a16616cfab9104e2a67687">rows</a>, <a class="code" href="namespaceppl_1_1util.html#adf3136a2bba83dcc18c39a41409d96a0">cols</a>);</div>
<div class="line">TParam&lt;ValueType, ShapeType&gt; tp(<a class="code" href="namespaceppl_1_1util.html#a249cf20fa5a16616cfab9104e2a67687">rows</a>, <a class="code" href="namespaceppl_1_1util.html#adf3136a2bba83dcc18c39a41409d96a0">cols</a>);</div>
</div><!-- fragment --><p>For all types listed above, <code>ValueType</code> should be either <code>double</code> or <code>int</code>, and <code>ShapeType</code> must be one of <code>scl, vec, mat</code> (scalar, column vector, matrix) to indicate the general shape. By default, <code>ShapeType</code> is <code>scl</code>. Depending on the shape, the user may omit <code>rows</code> or <code>cols</code>. For example, if <code>ShapeType</code> is <code>scl</code>, one can omit both <code>rows</code> and <code>cols</code> (both set to 1), and if <code>ShapeType</code> is <code>vec</code>, one can omit <code>cols</code> (set to 1). For <code>Param</code> specifically, see <a href="#constraint">Constraint</a> for more information about <code>ConstraintType</code>. For this section, this third template parameter is not important.</p>
<p>The difference between <code>DataView</code> and <code>Data</code> is that <code>DataView</code> only views existing data (does not copy any data) and <code>Data</code> <em>owns</em> data. <code>DataView</code> will view data in column major format and <code>Data</code> will own data in column major format. To get the underlying data that <code>DataView</code> views or <code>Data</code> owns, we expose the member function <code>get</code>, which will return a reference to <code>Eigen::Map</code> or <code>Eigen::Matrix</code>, respectively. We ask the users to refer to <code>Eigen</code> documentation for modifying the data.</p>
<p><code>Param</code> and <code>TParam</code> objects do not own or view any values. There is nothing to do from the user other than constructing them. More details on their distinction will become clearer in the later sections. At a high level, a <code>Param</code> is a parameter that can be sampled and a <code>TParam</code> is a transformation of parameters and is not sampled.</p>
<p>It is worth mentioning that currently <code>TParam&lt;T, vec&gt;</code> objects are the only ones that provide subsetting, i.e. have <code>operator[]</code> defined. There should be no need with <code>Data</code> or <code>DataView</code> since one can subset the underlying Eigen object itself and create a new <code>Data</code> or <code>DataView</code> object to own a copy of or view that subset. Note that <code>tp[i]</code> returns another expression and does not actually retrieve any value; it is simply a lightweight object that refers to <code>tp</code> and the <code>i</code>th value it represents. Users should not concern themselves how <code>tp</code> actually binds to values during MCMC.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Variable Expression</h2>
<p>Variable expressions are any expressions that are "mathematical" functions of variables. We provide overloads for <code>operator+,-,*,/,+=,-=,*=,/=,=</code>, functions such as <code>sin, cos, tan, log, exp, sqrt, dot, for_each</code>. All functions are vectorized whenever possible. Here is an example: </p><div class="fragment"><div class="line">Data&lt;double, mat&gt; X(m,n);</div>
<div class="line">Param&lt;double, vec&gt; w(n), w2(m);</div>
<div class="line">TParam&lt;double, scl&gt; s;</div>
<div class="line"><span class="keyword">auto</span> var_expr = sin(<a class="code" href="namespaceppl.html#a04b41c73306b6dfb41eb6b3eb788056d">dot</a>(X, w) + s) - w2;</div>
</div><!-- fragment --><p>The expression above first creates an expression for the dot-product, then a vectorized sum with a scalar (<code>s</code>), then a vectorized <code>sin</code>, then finally vectorized <code>operator-</code> with <code>w2</code>.</p>
<p>The only non-obvious function is <code>for_each</code>. It has the same syntax as <code>std::for_each</code>, however, the lambda function must return some variable expression: </p><div class="fragment"><div class="line">TParam&lt;double, vec&gt; h(10);</div>
<div class="line"><span class="keyword">auto</span> expr = <a class="code" href="namespaceppl.html#ad3d5823ebc58b089ab53f40477c3dff0">for_each</a>(util::counting_iterator&lt;size_t&gt;(0),</div>
<div class="line">                     util::counting_iterator&lt;size_t&gt;(h.size()),</div>
<div class="line">                     [&amp;](<span class="keywordtype">size_t</span> i) { return h[i] += h[i-1] * 2.; });</div>
</div><!-- fragment --><p>Note that we provide our own <code>counting_iterator</code> since they become quite useful in this context. One can think of this expression as a "lazy-version" of the following:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; h.size(); ++i) {</div>
<div class="line">    h[i] += h[i-1] * 2.;</div>
<div class="line">}</div>
</div><!-- fragment --><p>assuming <code>h</code> in this context is, for example, <code>std::vector&lt;double&gt;</code>. Again, nothing is computed when the expression is constructed. All computation is done lazily during MCMC sampling.</p>
<p>Finally, users can create constants by writing literals directly, as shown above, when constructing variable expressions. If the user wishes to create a constant vector or matrix, they can simply use those objects when constructing the variable expression and our library will wrap them as constant objects. The difference between constants and data is that constants cannot be assigned a distribution.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Constraint</h2>
<p>This section only applies to <code>Param</code> objects. Sometimes, parameters must be constrained. Some notable examples are covariance matrix (symmetric and positive definite), probability values (bounded by 0 and 1), and standard deviation (bounded below by 0). It is a well-known problem that sampling constrained parameters directly is highly-inefficient.</p>
<p>Every parameter has an associated unconstrained and constrained value. Most MCMC algorithms like NUTS and Metropolis-Hastings will sample unconstrained values, and transform the unconstrained values to constrained values when computing the log-pdf (corrected with the Jacobian). For more information on how these transformations are performed, we direct the readers to look at <a href="https://mc-stan.org/docs/2_21/reference-manual/variable-transforms-chapter.html">STAN reference guide</a>. Note that users will always receive <em>constrained</em> values as their samples after invoking a MCMC sampler.</p>
<p>Currently we only support lower bounds, lower-and-upper bounds, (symmetric) positive-definite, and no constraint. We recommend using C++17 class template argument deduction (CTAD) instead of <code>auto</code> to indicate that these objects are indeed parameters, but of course, one can certainly just use <code>auto</code>: </p><div class="fragment"><div class="line"><span class="comment">// Declaration pseudo-code:</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// make_param&lt;ValueType, ShapeType=scl, ConstraintType&gt;(rows, cols, constraint);</span></div>
<div class="line"><span class="comment">// make_param&lt;ValueType, ShapeType=scl, ConstraintType&gt;(rows, constraint);</span></div>
<div class="line"><span class="comment">// make_param&lt;ValueType, ShapeType=scl, ConstraintType&gt;(constraint);</span></div>
<div class="line"> </div>
<div class="line">Param sigma = make_param&lt;double&gt;(<a class="code" href="namespaceppl.html#af14b1cf5b7d344e4b0c94ed4475954c8">lower</a>(0.));                <span class="comment">// scalar lower bounded by 0.</span></div>
<div class="line">Param p = make_param&lt;double, vec&gt;(10, <a class="code" href="namespaceppl.html#a9b8c67b9ceee964e3e7ce051c2fc8270">bounded</a>(0., 1.));     <span class="comment">// 10-element vector bounded by 0., 1.</span></div>
<div class="line">Param Sigma = make_param&lt;double, mat&gt;(3, <a class="code" href="namespaceppl.html#abe838ab0f476b795babf3c0143080a21">pos_def</a>());        <span class="comment">// 3x3 covariance matrix</span></div>
</div><!-- fragment --><p>From section <a href="#variable">Variable</a>, we saw that <code>Param</code> had a third template parameter. Using the <code>make_param</code> helper function, we can deduce that third parameter type, which is precisely the constraint argument to <code>make_param</code>. In general, the constraint can be a complicated expression depending on other parameters as such: </p><div class="fragment"><div class="line">Param&lt;double&gt; w1;</div>
<div class="line">Param w2 = make_param&lt;double&gt;(<a class="code" href="namespaceppl.html#af14b1cf5b7d344e4b0c94ed4475954c8">lower</a>(w1 - 1. + w1 * w1));</div>
</div><!-- fragment --><p>so it is crucial that we are able to deduce the type.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Distribution Expression</h2>
<p>A distribution expression internally defines how to compute the log-pdf (dropping any constants). Currently we support the following distributions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Distribution  </th><th class="markdownTableHeadNone">Syntax   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli</a>  </td><td class="markdownTableBodyNone"><code>ppl::bernoulli(p)</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Cauchy_distribution">Cauchy</a>  </td><td class="markdownTableBodyNone"><code>ppl::cauchy(x0, gamma)</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Normal_distribution">Normal</a>  </td><td class="markdownTableBodyNone"><code>ppl::normal(mu, sigma)</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution">Multivariate Normal</a>  </td><td class="markdownTableBodyNone"><code>ppl::normal(mu, Sigma)</code>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">Uniform</a>  </td><td class="markdownTableBodyNone"><code>ppl::uniform(min, max)</code>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Wishart_distribution">Wishart</a>  </td><td class="markdownTableBodyNone"><code>ppl::wishart(V, n)</code>   </td></tr>
</table>
<p>Here are some examples: </p><div class="fragment"><div class="line">Param&lt;double&gt; m1, m2, M1, M2;</div>
<div class="line"><span class="keyword">auto</span> uniform_expr = <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(m1 + m2, M1 + M2);</div>
<div class="line"> </div>
<div class="line">Param&lt;double&gt; l1, l2, s;</div>
<div class="line"><span class="keyword">auto</span> normal_expr = <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(l1 + l2, s);</div>
<div class="line"> </div>
<div class="line">Param V = make_param&lt;double, mat&gt;(3, <a class="code" href="namespaceppl.html#abe838ab0f476b795babf3c0143080a21">pos_def</a>);</div>
<div class="line"><span class="keyword">auto</span> wishart_expr = <a class="code" href="namespaceppl.html#a8123d9b58485f399c7967c2af22143b6">wishart</a>(V, 5);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Model Expression</h2>
<p>There are two operators that govern model expressions: <code>operator|=</code> and <code>operator,</code>. <code>operator|=</code> assigns a distribution to a parameter or data and <code>operator,</code> "glues" such assignments together, defining a joint distribution. The choice for <code>operator|=</code> is deliberate because it captures both the intuition that we are assigning a distribution to a variable and that the distribution is <em>conditional</em> (<code>|</code>).</p>
<p>Example: </p><div class="fragment"><div class="line">Data&lt;double, vec&gt; y(10);</div>
<div class="line">Param&lt;double&gt; m1, m2, M1, M2;</div>
<div class="line">Param&lt;double&gt; l1, l2, s;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">    m1 |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(1., 1.),</div>
<div class="line">    m2 |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(-1., 1.),</div>
<div class="line">    M1 |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(m2, m1),</div>
<div class="line">    M2 |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(M, 3.24 + m1),</div>
<div class="line">    y |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(l1 + l2, s)</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Transformed Parameters</h2>
<p>There are cases where defining a model expression is not enough. Sometimes parameters have to be further transformed to cache some common transformation. For example, here is a stochastic volatility model taken from <a href="https://mc-stan.org/docs/2_21/stan-users-guide/stochastic-volatility-models.html">STAN</a>, but using AutoPPL:</p>
<div class="fragment"><div class="line">DataView&lt;double, vec&gt; y(ptr, n_data);</div>
<div class="line">Param phi = make_param&lt;double&gt;(<a class="code" href="namespaceppl.html#a9b8c67b9ceee964e3e7ce051c2fc8270">bounded</a>(-1., 1.));</div>
<div class="line">Param sigma = make_param&lt;double&gt;(<a class="code" href="namespaceppl.html#af14b1cf5b7d344e4b0c94ed4475954c8">lower</a>(0.));</div>
<div class="line">Param&lt;double&gt; mu;</div>
<div class="line">Param&lt;double, vec&gt; h_std(n_data);</div>
<div class="line">TParam&lt;double, vec&gt; h(n_data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define transformed parameter expression</span></div>
<div class="line"><span class="keyword">auto</span> tp_expr = (</div>
<div class="line">    h = h_std * sigma,</div>
<div class="line">    h[0] /= sqrt(1. - phi * phi),</div>
<div class="line">    h += mu,</div>
<div class="line">    <a class="code" href="namespaceppl.html#ad3d5823ebc58b089ab53f40477c3dff0">for_each</a>(util::counting_iterator&lt;&gt;(1),</div>
<div class="line">             util::counting_iterator&lt;&gt;(h.size()),</div>
<div class="line">             [&amp;](<span class="keywordtype">size_t</span> i) { return h[i] += phi * (h[i-1] - mu); })</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">    phi |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(-1., 1.),</div>
<div class="line">    sigma |= <a class="code" href="namespaceppl.html#a4f285434a88e7d8d60ab99e935088f8c">cauchy</a>(0., 5.),</div>
<div class="line">    mu |= <a class="code" href="namespaceppl.html#a4f285434a88e7d8d60ab99e935088f8c">cauchy</a>(0., 10.),</div>
<div class="line">    h_std |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0., 1.),</div>
<div class="line">    y |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0., exp(h / 2.))</div>
<div class="line">);</div>
</div><!-- fragment --><p>A couple of notes:</p><ul>
<li>transformed parameter expression <em>must</em> be defined as a separate expression from model expression</li>
<li>it is more efficient to make a transformed parameter expression if there is a common transformation used in multiple places when defining a model expression</li>
<li><p class="startli">all variable expressions are perfectly valid when defining TP expressions, but note that <code>operator=</code> is only available for <code>TParam</code> objects. In fact, all <code>TParam</code> objects that are used in a model expression <em>must have exactly one</em> <code>operator=</code> expression assigning some expression to that <code>TParam</code> object. The user cannot assign a vector <code>TParam</code> with some expression and then also assign a subview again like: </p><div class="fragment"><div class="line">h = h_std * sigma,</div>
<div class="line">h[0] = 1.</div>
</div><!-- fragment --><p class="startli">because this introduces ambiguity when back-evaluating during automatic differentiation. However, it is fine to assign each subview exactly once like: </p><div class="fragment"><div class="line"><a class="code" href="namespaceppl.html#ad3d5823ebc58b089ab53f40477c3dff0">for_each</a>(util::counting_iterator&lt;&gt;(0),</div>
<div class="line">         util::counting_iterator&lt;&gt;(h.size),</div>
<div class="line">         [&amp;](<span class="keywordtype">size_t</span> i) { return h[i] = h_std[i] * sigma; });</div>
</div><!-- fragment --></li>
<li>it is possible to assign a <code>TParam</code> with an expression composed of only data and constants, but this is much less efficient than precomputing that expression and creating a new constant out of that. This precomputation only requires using Eigen library and should not be a part of any autoppl expressions.</li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
Program Expression</h2>
<p>A program expression simply combines a transformed parameter expression with a model expression. If there is no transformed parameter expression, then a program expression simply wraps a model expression. A program expression is what gets passed to MCMC samplers. The user does not need to convert a model expression into a program expression, but if there is a transformed parameter expression, the user should use <code>operator|</code> to "pipe" transformed parameter expression with a model expression to create a program expression (order matters! The wrong order will raise a compiler error):</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> program = tp_expr | model;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Sampling Algorithms</h2>
<p>Currently, we support the following algorithms:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">MCMC Algorithm  </th><th class="markdownTableHeadNone">Syntax   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm">Metropolis-Hastings</a>  </td><td class="markdownTableBodyNone">ppl::mh(program, config)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="http://www.stat.columbia.edu/~gelman/research/published/nuts.pdf">No-U-Turn Sampler (NUTS)</a>  </td><td class="markdownTableBodyNone">ppl::nuts(program, config)   </td></tr>
</table>
<p>Every sampling algorithm has a corresponding configuration object associated with it. The user does not need to pass a configuration, in which case, a default-constructed object gets passed with the default settings.</p>
<p>We briefly list the configuration declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ConfigBase</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> warmup = 1000;               <span class="comment">// number of warmup iterations</span></div>
<div class="line">    <span class="keywordtype">size_t</span> samples = 1000;              <span class="comment">// number of samples</span></div>
<div class="line">    <span class="keywordtype">size_t</span> seed = <a class="code" href="namespaceppl_1_1mcmc.html#aaf8ea2c947abe09e32feb405a4ce76b1">mcmc::random_seed</a>();  <span class="comment">// seed (default: random)</span></div>
<div class="line">    <span class="keywordtype">bool</span> prune = <span class="keyword">true</span>;                  <span class="comment">// extra step during initialization to make sure log-pdf is not degenerate</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// MH-specific</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MHConfig : ConfigBase</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> sigma = 1.0;     <span class="comment">// proposal distribution SD (N(0, sigma))</span></div>
<div class="line">    <span class="keywordtype">double</span> alpha = 0.25;    <span class="comment">// discrete proposal distribution (triangular on {-1,0,1})</span></div>
<div class="line">                            <span class="comment">// with alpha probability on -1 and 1 (1-2*alpha on 0).</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// NUTS-specific</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StepConfig</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> delta = 0.8;</div>
<div class="line">    <span class="keywordtype">double</span> gamma = 0.05;</div>
<div class="line">    <span class="keywordtype">double</span> t0 = 10.;</div>
<div class="line">    <span class="keywordtype">double</span> kappa = 0.75;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>VarConfig</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> init_buffer = 75;</div>
<div class="line">    <span class="keywordtype">size_t</span> term_buffer = 50;</div>
<div class="line">    <span class="keywordtype">size_t</span> window_base = 25;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// template parameter one of: unit_var, diag_var</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> VarAdapterPolicy=diag_var&gt;</div>
<div class="line"><span class="keyword">struct </span>NUTSConfig: ConfigBase</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> var_adapter_policy_t = VarAdapterPolicy;</div>
<div class="line">    <span class="keywordtype">size_t</span> max_depth = 10;</div>
<div class="line">    StepConfig step_config;</div>
<div class="line">    VarConfig var_config;</div>
<div class="line">};</div>
</div><!-- fragment --><p>For the NUTS-specific configuration, we direct the reader to <a href="https://mc-stan.org/docs/2_18/reference-manual/hmc-algorithm-parameters.html">STAN</a>.</p>
<p>Every sampler will return a <code><a class="el" href="structppl_1_1_m_c_m_c_result.html">ppl::MCMCResult</a>&lt;&gt;</code> object. The template parameter indicates the row or column-major for the underlying sample matrix. The sampler may choose to sample the unconstrained values and write in a row-major result object for speed purposes and then convert to a column-major result object with constrained values. We briefly show the class declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> Major = Eigen::ColMajor&gt;</div>
<div class="line"><span class="keyword">struct </span>MCMCResult</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    cont_samples_t cont_samples;    <span class="comment">// (continuous) sample matrix</span></div>
<div class="line">    disc_samples_t disc_samples;    <span class="comment">// (discrete) sample matrix</span></div>
<div class="line">    std::string name;               <span class="comment">// MCMC algorithm name</span></div>
<div class="line">    <span class="keywordtype">double</span> warmup_time = 0;         <span class="comment">// time elapsed for warmup</span></div>
<div class="line">    <span class="keywordtype">double</span> sampling_time = 0;       <span class="comment">// time elapsed for sampling </span></div>
<div class="line">};</div>
</div><!-- fragment --><p>The sample matrices will always be <code>samples x n_constrained_values</code>, where <code>samples</code> is the number of samples requested from the config object and <code>n_constrained_values</code> is the number of constrained parameter values (flattened into a row). The algorithms guarantee that each row consists of sampled parameter values in the same order as the priors in the model. As an example, for the following model </p><div class="fragment"><div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">    t1 |= ...,</div>
<div class="line">    t2 |= ...,</div>
<div class="line">    t3 |= ...,</div>
<div class="line">    ...</div>
<div class="line">);</div>
</div><!-- fragment --><p>a sample row would consist of values for <code>t1</code>, <code>t2</code>, <code>t3</code> in that order. If the parameters are multi-dimensional, their values are flattened assuming column-major format. So if <code>t1</code> is a vector with 4 elements, the first four elements of a row will be values for <code>t1</code>. If <code>t2</code> is a 2x2 matrix, the next four elements of a row will be values for <code>t2(0,0), t2(1,0), t2(0,1), t2(1,1)</code>.</p>
<p>Currently, we do not support a <code>summary</code> function yet to output a summary of the samples. The user can, however, directly call <code>res.cont_samples.colwise().mean()</code> to compute the mean for each column. We also provide <code>ppl::math::ess(matrix)</code> to compute column-wise effective-sample-size (ESS). The user can then divide this result with <code>res.sampling_time</code> to get <code>ESS/s</code>, which is the preferred metric to compare performance among MCMC algorithms. ESS was computed as outlined <a href="https://mc-stan.org/docs/2_23/reference-manual/effective-sample-size-section.html">here</a>. We also made some adjustments to use Geyer's biased estimator for ESS as in the current implementation of STAN (<a href="https://github.com/stan-dev/stan/blob/525998129ea838ec685f1d1f65dc76063d0fd40d/src/stan/analyze/mcmc/compute_effective_sample_size.hpp">source</a>).</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Examples</h1>
<h2><a class="anchor" id="autotoc_md20"></a>
Sampling from Joint Distribution</h2>
<p>Although AutoPPL was designed to perform inference on posterior distributions, one can certainly use it to sample from any joint distribution defined by the priors and conditional distributions. For example, we can sample <code>1000</code> points with <code>1000</code> warmup iterations from a standard normal distribution using Metropolis-Hastings in the following way:</p>
<div class="fragment"><div class="line">Param&lt;double&gt; theta;</div>
<div class="line"><span class="keyword">auto</span> model = (theta |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0., 1.));</div>
<div class="line"><span class="keyword">auto</span> res = <a class="code" href="namespaceppl.html#a7fe3bc2188b78100bf0465edc26d74e4">mh</a>(model, config);</div>
</div><!-- fragment --><p>In general, so long as the joint PDF is known, or equivalently and more commonly if the conditional and prior PDFs are known, one can sample from the distribution. As another example, we may sample from a more complicated joint distribution: </p><div class="fragment"><div class="line">Param&lt;double&gt; theta1;</div>
<div class="line">Param&lt;double&gt; theta2;</div>
<div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">    theta1 |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(-1., 1.),</div>
<div class="line">    theta2 |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(theta1, 1.)</div>
<div class="line">);</div>
<div class="line"><span class="keyword">auto</span> res = <a class="code" href="namespaceppl.html#a7fe3bc2188b78100bf0465edc26d74e4">mh</a>(model); </div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md21"></a>
Sampling Posterior Mean and Standard Deviation</h2>
<p>The following is an example of fitting a Gaussian model to some data. We put a <code>Normal(0,3)</code> prior on the mean and <code>Uniform(0,2)</code> prior on the standard deviation. While in the previous section, we used Metropolis-Hastings to demonstrate how to use it, it is recommended to use the state-of-the-art NUTS sampler to sample from the posterior distribution.</p>
<div class="fragment"><div class="line">Data&lt;double, vec&gt; x(5);</div>
<div class="line">Param&lt;double&gt; mu;</div>
<div class="line">Param&lt;double&gt; sigma;</div>
<div class="line"> </div>
<div class="line">x.get() &lt;&lt; 1.0, 1.5, 1.7, 1.2, 1.5; <span class="comment">// load data</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">    mu |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0., 3.),</div>
<div class="line">    sigma |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(0., 2.),</div>
<div class="line">    x |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(mu, sigma)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = <a class="code" href="namespaceppl.html#a88ba12523376721bd8255c793546ef5e">nuts</a>(model);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
Bayesian Linear Regression</h2>
<p>This example covers ridge regression in a Bayesian setting. We created a fictitious dataset consisting of <code>(x,y)</code> coordinates. The true relationship is the following: <code>y = x + 1</code>. By specifying two parameters for the weight and bias, we propose the following probabilistic model:</p>
<div class="fragment"><div class="line">y ~ Normal(x*w + b, 0.5)</div>
<div class="line">w ~ Uniform(0, 2)</div>
<div class="line">b ~ Uniform(0, 2)</div>
</div><!-- fragment --><p>In AutoPPL, we can write the following code and sample from the posterior: </p><div class="fragment"><div class="line">Data&lt;double&gt; x(6); </div>
<div class="line">Data&lt;double&gt; y(6);</div>
<div class="line">Param&lt;double&gt; w;</div>
<div class="line">Param&lt;double&gt; b;</div>
<div class="line"> </div>
<div class="line">x.get() &lt;&lt; 2.4, 3.1, 3.6, 4, 4.5, 5.;</div>
<div class="line">y.get() &lt;&lt; 3.5, 4, 4.4, 5.01, 5.46, 6.1;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">        w |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(0., 2.),</div>
<div class="line">        b |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(0., 2.),</div>
<div class="line">        y |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(x * w + b, 0.5)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = <a class="code" href="namespaceppl.html#a88ba12523376721bd8255c793546ef5e">nuts</a>(model);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Stochastic Volatility</h2>
<p>This example was discussed in a previous section, but we mention it again as reference: </p><div class="fragment"><div class="line">DataView&lt;double, vec&gt; y(ptr, n_data);</div>
<div class="line">Param phi = make_param&lt;double&gt;(<a class="code" href="namespaceppl.html#a9b8c67b9ceee964e3e7ce051c2fc8270">bounded</a>(-1., 1.));</div>
<div class="line">Param sigma = make_param&lt;double&gt;(<a class="code" href="namespaceppl.html#af14b1cf5b7d344e4b0c94ed4475954c8">lower</a>(0.));</div>
<div class="line">Param&lt;double&gt; mu;</div>
<div class="line">Param&lt;double, vec&gt; h_std(n_data);</div>
<div class="line">TParam&lt;double, vec&gt; h(n_data);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> tp_expr = (</div>
<div class="line">    h = h_std * sigma,</div>
<div class="line">    h[0] /= sqrt(1. - phi * phi),</div>
<div class="line">    h += mu,</div>
<div class="line">    <a class="code" href="namespaceppl.html#ad3d5823ebc58b089ab53f40477c3dff0">for_each</a>(util::counting_iterator&lt;&gt;(1),</div>
<div class="line">             util::counting_iterator&lt;&gt;(h.size()),</div>
<div class="line">             [&amp;](<span class="keywordtype">size_t</span> i) { return h[i] += phi * (h[i-1] - mu); })</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">    phi |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(-1., 1.),</div>
<div class="line">    sigma |= <a class="code" href="namespaceppl.html#a4f285434a88e7d8d60ab99e935088f8c">cauchy</a>(0., 5.),</div>
<div class="line">    mu |= <a class="code" href="namespaceppl.html#a4f285434a88e7d8d60ab99e935088f8c">cauchy</a>(0., 10.),</div>
<div class="line">    h_std |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0., 1.),</div>
<div class="line">    y |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0., exp(h / 2.))</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = <a class="code" href="namespaceppl.html#a88ba12523376721bd8255c793546ef5e">nuts</a>(tp_expr | model);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md24"></a>
Benchmarks</h1>
<p>In the following examples, we show benchmarks with STAN.</p>
<p>We list the benchmark settings for completion:</p><ul>
<li>Machine: x86_64-apple-darwin19.5.0</li>
<li>CPU: 3.4 GHz Quad-Core Intel Core i5</li>
<li>Compiler: Clang 11.0.3</li>
</ul>
<h2><a class="anchor" id="autotoc_md25"></a>
Bayesian Linear Regression &lt;a name="benchmarks-bayesian-linear-regression"&gt;&lt;/a&gt;</h2>
<p>We collected a dataset regarding life expectancy released by WHO (<a href="https://www.kaggle.com/kumarajarshi/life-expectancy-who">source</a>). After cleaning and extracting three predictors: "Alcohol", "HIV/AIDS", and "GDP", the dataset consisted of 157 points. We performed a Bayesian linear regression with this data and the following model:</p>
<div class="fragment"><div class="line">y ~ Normal(X*w + b, s*s + 2.)</div>
<div class="line">w ~ Normal(0., 5.)</div>
<div class="line">b ~ Normal(0., 5.)</div>
<div class="line">s ~ Uniform(0.5, 8.)</div>
</div><!-- fragment --><p>where <code>w</code> is a 3-dimensional parameter vector, and <code>b</code> and <code>s</code> are scalar parameters.</p>
<p>Using the same dataset and model specification, we performed NUTS to sample various number of samples. We also set the number of chains and cores to 1 and adaptation method to diagonal precision matrix.</p>
<p>The following plots show benchmarks between run-times and effective sample size (ESS) per second:</p>
<p><img src="docs/figures/regression_benchmark_plot/runtime.png" alt="" class="inline"/> <img src="docs/figures/regression_benchmark_plot/ess_s.png" alt="" class="inline"/></p>
<p>The reported mean, standard deviation, and ESS values were almost identical in all cases, which is not surprising since we used the same algorithm to estimate ESS and perform NUTS.</p>
<p>The runtimes have similar log-like behavior, but it is clear that STAN (dotted lines) takes far longer in both sampling and warmup times by a factor of about 6.5-7. As for ESS/s, upon comparing by colors (corresponding to a parameter) between dotted (STAN) and solid (AutoPPL) lines, we see that AutoPPL has uniformly larger ESS/s by a factor of 6.5-7 as well. This difference quickly becomes more noticeable as sample size grows. From these plots and that sampling results were identical show that the drastic difference in ESS/s is simply from faster automatic differentation and a good use of memory to take advantage of cache.</p>
<p>The following is the AutoPPL code for the model specification without data loading. The full code can be found <a href="benchmark/regression_autoppl.cpp">here</a>:</p>
<div class="fragment"><div class="line">DataView&lt;double, mat&gt; X(X_data.data(), X_data.rows(), X_data.cols());</div>
<div class="line">DataView&lt;double, vec&gt; y(y_data.data(), y_data.rows());</div>
<div class="line">Param&lt;double, vec&gt; w(3);</div>
<div class="line">Param&lt;double&gt; b;</div>
<div class="line">Param&lt;double&gt; s;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> model = (s |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(0.5, 8.),</div>
<div class="line">              b |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0., 5.),</div>
<div class="line">              w |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0., 5.),</div>
<div class="line">              y |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(<a class="code" href="namespaceppl.html#a04b41c73306b6dfb41eb6b3eb788056d">dot</a>(X, w) + b, s * s + 2.));</div>
<div class="line"> </div>
<div class="line">NUTSConfig&lt;&gt; config;</div>
<div class="line">config.warmup = num_samples;</div>
<div class="line">config.samples = num_samples;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = <a class="code" href="namespaceppl.html#a88ba12523376721bd8255c793546ef5e">nuts</a>(model, config);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
Gaussian Model</h2>
<p>We generated 1000 values from standard normal distribution to form our data. Our model is defined as follows:</p>
<div class="fragment"><div class="line">y ~ Normal(l1 + l2, s) </div>
<div class="line">l1 ~ Normal(0., 10.)</div>
<div class="line">l2 ~ Normal(0., 10.)</div>
<div class="line">s ~ Uniform(0., 20.)</div>
</div><!-- fragment --><p>where all parameters are scalar. The benchmark configurations are exactly the same as in the <a href="#benchmarks-bayesian-linear-regression">previous section</a>. The following plots show benchmarks between run-times and effective sample size (ESS) per second:</p>
<p><img src="docs/figures/gaussian_benchmark_plot/runtime.png" alt="" class="inline"/> <img src="docs/figures/gaussian_benchmark_plot/ess_s.png" alt="" class="inline"/></p>
<p>We note that both STAN and AutoPPL outputted almost identical means, standard deviation, and ESS.</p>
<p>The runtimes have a similar linear trend, and it is clear that STAN (dotted lines) takes far longer in both sampling and warmup times. Comparing the sampling times, for example, we see about 20 times improvement. The ESS/s for <code>l1</code> and <code>l2</code> overlap completely (red and blue) in both STAN and AutoPPL and this is expected since they are symmetric in the model specification. With the exception of the two smallest sample sizes (100, 500), ESS/s is fairly constant as sample size varies. It is quite evident that AutoPPL (solid) has a larger ESS/s by a factor of 20.</p>
<p>The reason for this difference is in how we handle expressions where data vector elements are iid (independent and identically distributed). For most distributions, especially those that are in some exponential family, they can be highly optimized in iid settings to perform quicker differentiation. However, it is worth noting that this optimization does not apply when the data are simply independent but not identically distributed (as in the <a href="#benchmarks-bayesian-linear-regression">linear regression</a> case), or when the variable is a parameter, not data. Nonetheless, our AD is extremely fast due to vectorization and is in general faster than STAN.</p>
<p>The following is the AutoPPL code without data generation. The full code can be found <a href="benchmark/normal_two_prior_distribution.cpp">here</a>.</p>
<div class="fragment"><div class="line">Data&lt;double, vec&gt; y(n_data);</div>
<div class="line">Param&lt;double&gt; lambda1, lambda2, sigma;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> model = (</div>
<div class="line">    sigma |= <a class="code" href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">uniform</a>(0.0, 20.0),</div>
<div class="line">    lambda1 |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0.0, 10.0),</div>
<div class="line">    lambda2 |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(0.0, 10.0),</div>
<div class="line">    y |= <a class="code" href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">normal</a>(lambda1 + lambda2, sigma)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">NUTSConfig&lt;&gt; config;</div>
<div class="line">config.n_samples = n_samples;</div>
<div class="line">config.warmup = n_samples;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = <a class="code" href="namespaceppl.html#a88ba12523376721bd8255c793546ef5e">nuts</a>(model, config);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md27"></a>
Contributors</h1>
<table class="doxtable">
<tr>
<td align="center"><a href="https://jacobaustin123.github.io/"><img src="https://avatars0.githubusercontent.com/u/28993550?v=4" alt="" width="100px;" class="inline"/><sub><b>Jacob Austin</b></sub></a><br  />
<a href="https://github.com/JamesYang007/autoppl/commits?author=jacobaustin123" title="Code">💻</a> <a href="#design-jacobaustin123" title="Design">🎨</a> <a href="https://github.com/JamesYang007/autoppl/commits?author=jacobaustin123" title="Documentation">📖</a> </td><td align="center"><a href="http://jenny-chen.net"><img src="https://avatars0.githubusercontent.com/u/13106682?v=4" alt="" width="100px;" class="inline"/><sub><b>Jenny Chen</b></sub></a><br  />
<a href="https://github.com/JamesYang007/autoppl/commits?author=jenchen1398" title="Code">💻</a> <a href="#design-jenchen1398" title="Design">🎨</a> </td><td align="center"><a href="https://github.com/lucieleblanc"><img src="https://avatars3.githubusercontent.com/u/14223323?v=4" alt="" width="100px;" class="inline"/><sub><b>lucieleblanc</b></sub></a><br  />
<a href="https://github.com/JamesYang007/autoppl/commits?author=lucieleblanc" title="Code">💻</a> <a href="#design-lucieleblanc" title="Design">🎨</a> </td><td align="center"><a href="http://lancaster.ac.uk/~ludkinm/"><img src="https://avatars3.githubusercontent.com/u/28777642?v=4" alt="" width="100px;" class="inline"/><sub><b>Matt Ludkin</b></sub></a><br  />
<a href="https://github.com/JamesYang007/autoppl/commits?author=ludkinm" title="Code">💻</a>  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md28"></a>
Third Party Tools</h1>
<p>Many thanks to the following third party tools used in this project:</p><ul>
<li><a href="https://clang.llvm.org/">Clang</a>: one of the main compilers used.</li>
<li><a href="https://cmake.org/">CMake</a>: build system.</li>
<li><a href="https://coveralls.io/">Coveralls</a>: check test coverage.</li>
<li><a href="https://github.com/eddyxu/cpp-coveralls">Cpp Coveralls</a>: check test coverage specifically for C++ code.</li>
<li><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>: matrix library.</li>
<li><a href="https://github.com/JamesYang007/FastAD">FastAD</a>: automatic differentiation library.</li>
<li><a href="https://gcc.gnu.org/">GCC</a>: one of the main compilers used.</li>
<li><a href="https://github.com/google/benchmark">Google Benchmark</a>: benchmark library algorithms.</li>
<li><a href="https://github.com/google/googletest">GoogleTest</a>: unit/integration-tests.</li>
<li><a href="https://travis-ci.org/">Travis CI</a>: continuous integration for Linux using GCC.</li>
<li><a href="http://valgrind.org/">Valgrind</a>: check memory leak and errors. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceppl_html_a7fe3bc2188b78100bf0465edc26d74e4"><div class="ttname"><a href="namespaceppl.html#a7fe3bc2188b78100bf0465edc26d74e4">ppl::mh</a></div><div class="ttdeci">auto mh(const ExprType &amp;expr, const MHConfig &amp;config=MHConfig())</div><div class="ttdef"><b>Definition:</b> mh.hpp:141</div></div>
<div class="ttc" id="anamespaceppl_html_ad3d5823ebc58b089ab53f40477c3dff0"><div class="ttname"><a href="namespaceppl.html#ad3d5823ebc58b089ab53f40477c3dff0">ppl::for_each</a></div><div class="ttdeci">constexpr auto for_each(Iter begin, Iter end, F f)</div><div class="ttdef"><b>Definition:</b> for_each.hpp:93</div></div>
<div class="ttc" id="anamespaceppl_html_a3269a968a2def2e819174255ec25c6b2"><div class="ttname"><a href="namespaceppl.html#a3269a968a2def2e819174255ec25c6b2">ppl::normal</a></div><div class="ttdeci">constexpr auto normal(const MeanType &amp;mean_expr, const SDType &amp;sd_expr)</div><div class="ttdef"><b>Definition:</b> normal.hpp:189</div></div>
<div class="ttc" id="anamespaceppl_html_a6cee3efc3fcd417738e799dd7168700a"><div class="ttname"><a href="namespaceppl.html#a6cee3efc3fcd417738e799dd7168700a">ppl::uniform</a></div><div class="ttdeci">constexpr auto uniform(const MinType &amp;min_expr, const MaxType &amp;max_expr)</div><div class="ttdef"><b>Definition:</b> uniform.hpp:222</div></div>
<div class="ttc" id="anamespaceppl_1_1util_html_adf3136a2bba83dcc18c39a41409d96a0"><div class="ttname"><a href="namespaceppl_1_1util.html#adf3136a2bba83dcc18c39a41409d96a0">ppl::util::cols</a></div><div class="ttdeci">constexpr size_t cols(const T &amp;x)</div><div class="ttdef"><b>Definition:</b> value.hpp:42</div></div>
<div class="ttc" id="anamespaceppl_html_af14b1cf5b7d344e4b0c94ed4475954c8"><div class="ttname"><a href="namespaceppl.html#af14b1cf5b7d344e4b0c94ed4475954c8">ppl::lower</a></div><div class="ttdeci">constexpr auto lower(const LowerType &amp;expr)</div><div class="ttdef"><b>Definition:</b> lower.hpp:256</div></div>
<div class="ttc" id="anamespaceppl_html_abe838ab0f476b795babf3c0143080a21"><div class="ttname"><a href="namespaceppl.html#abe838ab0f476b795babf3c0143080a21">ppl::pos_def</a></div><div class="ttdeci">constexpr auto pos_def()</div><div class="ttdef"><b>Definition:</b> pos_def.hpp:241</div></div>
<div class="ttc" id="anamespaceppl_html_a9b8c67b9ceee964e3e7ce051c2fc8270"><div class="ttname"><a href="namespaceppl.html#a9b8c67b9ceee964e3e7ce051c2fc8270">ppl::bounded</a></div><div class="ttdeci">constexpr auto bounded(const LowerType &amp;lower, const UpperType &amp;upper)</div><div class="ttdef"><b>Definition:</b> bounded.hpp:283</div></div>
<div class="ttc" id="anamespaceppl_html_a8123d9b58485f399c7967c2af22143b6"><div class="ttname"><a href="namespaceppl.html#a8123d9b58485f399c7967c2af22143b6">ppl::wishart</a></div><div class="ttdeci">constexpr auto wishart(const VType &amp;v_expr, const NType &amp;n_expr)</div><div class="ttdef"><b>Definition:</b> wishart.hpp:121</div></div>
<div class="ttc" id="anamespaceppl_1_1mcmc_html_aaf8ea2c947abe09e32feb405a4ce76b1"><div class="ttname"><a href="namespaceppl_1_1mcmc.html#aaf8ea2c947abe09e32feb405a4ce76b1">ppl::mcmc::random_seed</a></div><div class="ttdeci">size_t random_seed()</div><div class="ttdef"><b>Definition:</b> sampler_tools.hpp:10</div></div>
<div class="ttc" id="anamespaceppl_html_a4f285434a88e7d8d60ab99e935088f8c"><div class="ttname"><a href="namespaceppl.html#a4f285434a88e7d8d60ab99e935088f8c">ppl::cauchy</a></div><div class="ttdeci">constexpr auto cauchy(const LocType &amp;loc_expr, const ScaleType &amp;scale_expr)</div><div class="ttdef"><b>Definition:</b> cauchy.hpp:170</div></div>
<div class="ttc" id="anamespaceppl_html_a88ba12523376721bd8255c793546ef5e"><div class="ttname"><a href="namespaceppl.html#a88ba12523376721bd8255c793546ef5e">ppl::nuts</a></div><div class="ttdeci">auto nuts(const ExprType &amp;expr, const NUTSConfigType &amp;config=NUTSConfigType())</div><div class="ttdef"><b>Definition:</b> nuts.hpp:645</div></div>
<div class="ttc" id="anamespaceppl_1_1util_html_a249cf20fa5a16616cfab9104e2a67687"><div class="ttname"><a href="namespaceppl_1_1util.html#a249cf20fa5a16616cfab9104e2a67687">ppl::util::rows</a></div><div class="ttdeci">constexpr size_t rows(const T &amp;x)</div><div class="ttdef"><b>Definition:</b> value.hpp:32</div></div>
<div class="ttc" id="anamespaceppl_html_a04b41c73306b6dfb41eb6b3eb788056d"><div class="ttname"><a href="namespaceppl.html#a04b41c73306b6dfb41eb6b3eb788056d">ppl::dot</a></div><div class="ttdeci">constexpr auto dot(const LHSVarExprType &amp;lhs, const RHSVarExprType &amp;rhs)</div><div class="ttdef"><b>Definition:</b> dot.hpp:103</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
